---
title: 什么是闭包
date: 2021-09-03 14:26:30
tags: ["闭包", "closure"]
---

# 闭包

啥是闭包，简单点来讲就是你在一个函数里返回了一个函数，在返回的这个函数内，你具有访问包裹它的函数作用域内的变量的能力。
   一般来说在我们声明的函数体内声明变量，只会在函数被调用时在当前函数块的作用域内存在。当函数执行完毕后会垃圾回收。但，如果我们返回的函数中存在对那个变量的引用，那这个变量便不会在函数调用后被销毁。也基于这一特性，延展出很多闭包的应用，如常见的防抖(debounce)、节流(throttle)函数，它们都是不断对内部的一个定时器进行操作；又如一些递归的缓存结果优化，也是设置了一个内部对象去比对结果来跳过一些冗余的递归场景。

```js
// 一个比较常见的节流函数
function throttle(fn, wait) {
  let timeStart = 0; // 不会被销毁，返回的函数执行时具有访问该变量的能力
  return function (...args) {
    let timeEnd = Date.now();
    if (timeEnd - timeStart > wait) {
      fn.apply(this, args);
      timeStart = timeEnd;
    }
  };
}
```

# HOC（高阶函数 or 组件）与 Compose（组合）

啥是高阶函数，其实跟上面的闭包的操作手段有点像，最终都会再返回一个函数。只不过它会根据你实际需求场景进行一些附加的操作来“增强”传入的原始函数的功能。像 React 中的一些 HOC（高阶组件）的应用其实也是同理，毕竟 class 也不过是 function 的语法糖。网上的应用场景也很多，这里不赘述了。主要再提一嘴的是 compose 函数，它能让我们在进行多层高阶函数嵌套时，书写代码更为清晰。如我们有高阶函数 A、B、C ，要实现 A(B(C(...args)))的效果，如果没有 compose，就需要不断地将返回结果赋值，调用。而使用 compose，只需要一次赋值 let HOC = compose(A, B, C);，然后调用 HOC(...args)即可。
   瞅瞅 compose 源码，比较简单，无传参时，返回一个按传入返回的函数；一个入参时，直接返回第一个入参函数；多个则用数组的 reduce 方法进行迭代，最终返回组合后的结果：

```js
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(
    (a, b) =>
      (...args) =>
        a(b(...args))
  );
}
```
