---
title: 构造函数
date: 2021-10-20 8:46:01
tags: ["构造函数", "原形", "原型链"]
categories: 甲骨文
---

# 构造函数

## 1.静态成员

​ 在构造函数本身上添加的成员称为静态成员,

​ 只能有构造函数本身访问

## 2.实例成员

​ 在构造函数内部通过 this 创建的成员称为实例成员,

​ 只能由实例化的对象来访问

# prototype 原型

### 原型是什么？

一个对象,我们也称为 prototype 为原型对象

### 原形的作用是什么？

共享方法 ，只要我们把我们的方法定义到原型对象上,那么所有的实例都可以使用我们的这个方法,而且不需要再开辟内存空间了,比较节约我们的内存资源

### 一般情况下我们的公共属性定义到构造函数里边

### 公共的方法放到原型对象上边

# **proto**隐试原型

```
每个对象都会有一个属性__proto__指向构造函数的prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有__proto__原形的存在
```

### **proto**对象原型和原型对象 prototype 是等价的

```
实例.__proto__ === 构造函数.prototype
```

```
方法的查找规则：
	首先看实例对象上边是否有要查找的方法,如果有就执行这个对象上的方法
	如果没有,因为有__proto__的存在,就去构造函数原型对象prototype身上去查找这个方法
```

```
__proto__对象原形的存在意义就在于为对象的查找机制提供一个方向,或者说一个路线,但是然是一个非标准属性,因此市级开发中,不可以使用这个属性,他只是内部指向原型对象prototype
```

# constructor 构造函数

```\
对象原型(__proto__)和构造函数(prototype)原型对象里面都有一个属性constructor属性,constructor我们称为构造函数,因为它指回构造函数本身。
```

```
constructor的作用：
	主要用与记录该对象引用于哪一个构造函数,他可以让原型对象重新指向原来的构造函数
```

### 很多情况下我们需要手动的利用 constructor 这个属性只会原来的构造函数

![image-20211019211839777](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019211839777.png)

```
这种情况的话他会把你原来的constructor给覆盖掉，constructor就会消失,这时候我们就要手动指向我们原来的构造函数
```

![image-20211019212112685](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019212112685.png)

```
总结：
	如果我们修改了原来的原形对象,给原形赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
```

# 构造函数、实例、原型对象 三者之间的关系

![image-20211019212620650](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019212620650.png)

# 原型链

```
构造函数里边的原型对象里边的__proto__原形指向的是 Object.prototype
```

![image-20211019213258929](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20211019213258929.png)
