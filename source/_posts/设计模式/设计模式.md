---
title: JavaScript设计模式
date: 2023-04-17 11:27:13
tags: ["js"]
categories: js
---

# <b>JavaScript设计模式</b>

<br/>

- [什么是设计模式](##<b>一、什么是设计模式</b>)
- [设计原则](##<b>二、设计模式遵循的原则</b>)
- [分类及详解（23种设计模式）](##<b>三、设计模式分类</b>)
- [代码重构](##<b>四、代码重构</b>)
- [参考图](##<b>五、附录：设计模式图示</b>)
- [参考文档](##<b>六、参考文档来源</b>)

<br/>

## <b>一、什么是设计模式</b>

<br/>

### <b>1、概念</b>

<br/>

>设计模式的定义：<b style='color:yellow'>在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</b>

<br/>

设计模式是解决某个特定场景下对某种问题的解决方案。因此，当我们遇到合适的场景时，我们可能会条件反射一样自然而然想到符合这种场景的设计模式。

<br/>

比如，当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题。

<br/>

设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。

<br/>

设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性

<br/>

## <b>二、设计模式遵循的原则</b>

<br/>

### <b>三大设计原则</b>

<br/>

- <b style='color:yellow'>SRP(Single Responsibility Principle) 单一职责原则</b>

  >就一个类而言，应仅有一个引起它变化的原因。

  <br/>
  
  <b>一个对象/方法，只做一件事情。</b>

  单一职责原则（SRP）的职责被定义为“引起变化的原因”。 如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。
  
  <br/>

  <b>SRP原则是所有原则中最简单也是最难正确运用的原则之一。</b>
  
  <b style='color:red'>要明确的是，并不是所有的职责都应该一一分离。</b>

  - <span style='color:red'>一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。</span>比如在ajax请求的时候，创建xhr对象和发送xhr请求几乎总是在一起的，那么创建xhr对象的职责和发送xhr请求的职责就没有必要分开。

  - <span style='color:red'>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，</span>即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的时候再进行分离也不迟。

  <br/>
  
  <b>SRP原则的优缺点</b>

  SRP原则的优点是降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责。

  <br/>

- <b style='color:yellow'>LKP(Least Knowledge Principle) 最少知识原则</b>

  >一个软件实体应当尽可能少地与其他实体发生相互作用。
  
  <br/>

  <b style='color:red'>注意：</b>这里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

  <br/>

  <b>减少对象之间的联系</b>

  最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。

  <br/>
  
  <b>迪米特法则（Law of Demeter，LoD）</b>

  最少知识原则也叫迪米特法则（Law of Demeter，LoD），“迪米特”这个名字源自1987年美国东北大学一个名为“Demeter”的研究项目。
  在实际开发中，是否选择让代码符合最少知识原则，要根据具体的环境来定。

  <br/>

- <b style='color:yellow'>OP(OpenClosed Principle) 开放/封闭原则</b>

  >软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改。

  <br/>

  <b>当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。</b>

  <br/>

  <b>实践方法：</b>

  - 用对象的多态性消除条件分支

  - 找出变化的地方

  找出程序中将要发生变化的地方，把变化封装起来，稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，变化的部分使用如下方法。

  - 放置挂钩
  - 使用回调函数

  <br/>

  <b>开放-封闭原则与设计模式</b>

  <u><b>不管是具体的各种设计模式，还是更抽象的面向对象设计原则，</b>比如单一职责原则、最少知识原则、依赖倒置原则等，<b>都是为了让程序遵守开放-封闭原则而出现的。</b></u>


<br/>

### <b>其他设计原则</b>

<br/>

- <b style='color:yellow'>LSP(Liskov Substitution Principle) 里氏替换原则</b>
  
  - 子类能覆盖(替换)父类
  - 父类能出现的地方子类就能出现
  - 子类可以扩展父类的功能，但不能改变父类原有的功能。

- <b style='color:yellow'>ISP(Interface Segregation Principle) 接口隔离原则</b>

  - 保持接口的单一独立
  - 类似单一职责原则，这里更关注接口
  
- <b style='color:yellow'>DIP(Dependency Inversion Principle) 依赖倒转原则</b>

  - 面向接口编程，依赖于抽象而不依赖于具体
  - 使用方只关注接口而不关注具体类的实现

- <b style='color:yellow'>CRP/CARP(Composite/Aggregate Reuse Principle) 合成复用原则，又叫组合/聚合复用原则</b> 

  - 提高系统的封装性，提高了内聚。因为继承会把父类的成员变量和方法的实现都暴露给子类，一旦父类修改，子类也得修改。
  - 使系统更加灵活，降低类之间的耦合程度。
  - 提高了类的可重用性。
  

<br/>

## <b>三、设计模式分类</b>

<br/>

>JavaScript中的设计模式一共23种，分为以下三类

<br/>

- 创建型

  - [单例模式](###<b>单例模式</b>)
  - [原型模式（简单工厂模式）](###<b>简单工厂模式</b>)
  - [工厂模式](###<b>工厂方法</b>)
  - [抽象工厂模式](###<b>抽象工厂</b>)
  - [建造者模式（生成器）](###<b>建造者模式</b>)

- 结构型

  - [适配器模式](###<b>适配器模式</b>)
  - [装饰器模式](###<b>装饰器模式</b>)
  - [代理模式](###<b>代理模式</b>)
  - [外观模式](###<b>外观模式</b>)
  - [桥接模式](###<b>桥接模式</b>)
  - [组合模式](###<b>组合模式</b>)
  - [享元模式](###<b>享元模式</b>)

- 行为型

  - [观察者模式](###<b>观察者模式</b>)
  - [迭代器模式](###<b>迭代器模式</b>)
  - [策略模式](###<b>策略模式</b>)
  - [模板方法模式](###<b>模板方法</b>)
  - [职责链（责任链）模式](###<b>责任链模式</b>)
  - [命令模式](###<b>命令模式</b>)
  - [备忘录模式](###<b>备忘录模式</b>)
  - [状态模式](###<b>状态模式</b>)
  - [访问者模式](###<b>访问者模式</b>)
  - [中介者模式](###<b>中介者模式</b>)
  - [解释器（解析器）模式](###<b>解析器模式</b>)

<br/>

### <b>设计模式比较</b>

<br/>

| 所属类型 | 模式名称 | 模式 | 简单定义 |
|:-|:-|:-|:-|
| 创建型 | Singleton | <b style='color:red'>单例</b> | 保证一个类只有一个实例，并提供一个访问它的全局访问点。
|:-|:-|:-|:-|
| 创建型 | Abstract Factory | 抽象工厂 | 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。
|:-|:-|:-|:-|
| 创建型 | Factory Method | <b style='color:red'>工厂方法</b> | 定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。
|:-|:-|:-|:-|
| 创建型 | Builder | 生成器 | 将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。
|:-|:-|:-|:-|
| 创建型 | Prototype | 原型 | 用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。
|:-|:-|:-|:-|
| 结构型 | Flyweight | <b style='color:red'>享元</b> | 享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。
|:-|:-|:-|:-|
| 结构型 | Bridge | 桥接 | 将抽象部分与它的实现部分相分离，使他们可以独立的变化。
|:-|:-|:-|:-|
| 结构型 | Composite | 组合模式 | 将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。
|:-|:-|:-|:-|
| 结构型 | FAÇADE | 外观 | 为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。
|:-|:-|:-|:-|
| 结构型 | Adapter | 适配器 | 将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。
|:-|:-|:-|:-|
| 结构型 | Decorator | <b style='color:red'>装饰器</b> | 动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。
|:-|:-|:-|:-|
| 结构型 | Proxy | <b style='color:red'>代理</b> | 为其他对象提供一种代理以控制对这个对象的访问
|:-|:-|:-|:-|
| 行为型 | Iterator | 迭代器 | 提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。
|:-|:-|:-|:-|
| 行为型 | Observer | <b style='color:red'>观察者</b> | 定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。
|:-|:-|:-|:-|
| 行为型 | Template Method | 模板方法 | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，Template Method使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。
|:-|:-|:-|:-|
| 行为型 | Command | 命令 | 将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。
|:-|:-|:-|:-|
| 行为型 | State | 状态 | 允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。
|:-|:-|:-|:-|
| 行为型 | Strategy | 策略模式 | 定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。
|:-|:-|:-|:-|
| 行为型 | China  of Responsibility | 职责链 | 使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系
|:-|:-|:-|:-|
| 行为型 | Mediator | 中介者 | 用一个中介对象封装一些列的对象交互。
|:-|:-|:-|:-|
| 行为型 | Visitor | 访问者模式 | 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。
|:-|:-|:-|:-|
| 行为型 | Interpreter | 解释器 | 给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
|:-|:-|:-|:-|
| 行为型 | Memento | 备忘录 | 在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
|:-|:-|:-|:-|
 <td colspan='4'><b style='color:red'>注意：</b>红色为最常用设计模式</td>

<br/>

<br/>

### <b>1、创建型</b>

<br/>

>图例

![](img/11-1.png)

<br/>

### <b>单例模式</b>

<br/>

<b>三要素：</b>

- 同一个实例
- 类自行创建实例对象
- 可向整个系统输出这个实例

<b>分类：</b>

- 饿汉式（ 类加载到实例时创建实例对象）
- 懒汉式（ 第一次使用时才创建实例对象）

<b>代码示例：</b>

```js
//示例一

 class LoginForm {
    constructor() {
        this.state = 'hide'
    }
    show() {
        if (this.state === 'show') {
            alert('已经显示')
            return
        }
        this.state = 'show'
        console.log('登录框显示成功')
    }
    hide() {
        if (this.state === 'hide') {
            alert('已经隐藏')
            return
        }
        this.state = 'hide'
        console.log('登录框隐藏成功')
    }
 }
 LoginForm.getInstance = (function () {
     let instance
     return function () {
        if (!instance) {
            instance = new LoginForm()
        }
        return instance
     }
 })()

let obj1 = LoginForm.getInstance()
obj1.show()

let obj2 = LoginForm.getInstance()
obj2.hide()

console.log(obj1 === obj2)

//懒汉式

// 手机 用来打电话，玩游戏，看电影，且都是同一个手机
 
var Phone = (function () {
    // 规定只能使用 Phone.getInstance 获取实例
    var res = function () {
        throw new Error("Please use Phone.getInstance() to get the object.");
    };
    var has = false;
    var phone = null;
    Object.defineProperty(res, 'getInstance', {
        value: function () { 
            if (has) {
                return phone;
            } else {
                has = true;
                // 调用时才创建实例
                phone = {
                    call () {
                        console.log("打电话");
                    },
                    playGame () {
                        console.log("玩游戏");
                    },
                    watchMovie () {
                        console.log("看电影");
                    }
                }
                return phone;
            }
        },
        writable: false,
        configurable: false,
        enumerable: false
    });
    return res;
}());
 
var p1 = Phone.getInstance();
var p2 = Phone.getInstance();
var p3 = Phone.getInstance();
p1.call();
p2.playGame();
p3.watchMovie();
console.log(p1 === p2 && p2 === p3);


// 饿汉式

// 手机 用来打电话，玩游戏，看电影，且都是同一个手机
// 规定只能使用 Phone.getInstance 获取实例

var Phone = (function () {
    // 在此创建实例，装入内存时 实例已创建
    var phone = {
        call () {
            console.log("打电话");
        },
        playGame () {
            console.log("玩游戏");
        },
        watchMovie () {
            console.log("看电影");
        }
    };
    var res = function () {
        throw new Error("Please use Phone.getInstance() to get the object.");
    };
    Object.defineProperty(res, 'getInstance', {
        value: function () {
            return phone;
        },
        writable: false,
        configurable: false,
        enumerable: false
    });
    return res;
}());
 
var p1 = Phone.getInstance();
var p2 = Phone.getInstance();
var p3 = Phone.getInstance();
p1.call();
p2.playGame();
p3.watchMovie();
console.log(p1 === p2 && p2 === p3);
 
Phone.getInstance = function () {
    console.log("I am Groot!");
}
var p4 = Phone.getInstance();
p4.call();
```

<br/>

### <b>简单工厂模式</b>

<br/>

<b>定义：</b>

定义一个工厂，工厂定义一个方法，该方法可以根据传入的参数去返回某一个类的实例。

<b>代码示例：</b>

```js
class Person {
  constructor(name) {
    this.name = name
  }
  getName() {
    return this.name
  }
}
class Student extends Person {
  constructor(name) {
    super(name)
  }
  sayHello() {
    console.log(`Hello， My name is ${this.name}`)
  }
}

let student = new Student("xiaoming")
student.sayHello()





// 根据参数决定去实例汽车还是摩托车
 
// 定义接口
const Vehicle = {
    run () {
        console.log(this.name + '跑...');
    }
}
 
//汽车类
function Car () {
    this.name = "汽车";
}
Car.prototype = Object.assign(Vehicle);
 
//摩托车类
function Moto () {
    this.name = "摩托车";
}
Moto.prototype = Object.assign(Vehicle);
 
// 车库
const Garage = {
    chooseVehicle (constructor) {
        return new constructor();
    }
};
Object.freeze(Garage);
 
var car = Garage.chooseVehicle(Car);
var moto = Garage.chooseVehicle(Moto);
car.run();
moto.run();
```

<br/>

### <b>工厂方法</b>

<br/>

<b>简要：</b>

定义一个工厂接口，接口存在一个创建产品类的方法，为每个类创建一个这样的类工厂。

<b>代码示例：</b>

```js
class Product {
    constructor(name) {
        this.name = name
    }
    init() {
        console.log('init')
    }
    fun() {
        console.log('fun')
    }
}

class Factory {
    create(name) {
        return new Product(name)
    }
}

// use
let factory = new Factory()
let p = factory.create('p1')
p.init()
p.fun()




// 工厂方法，创建工厂接口，为每个类创建一个工厂

// 定义接口
const Vehicle = {
    run () {
        console.log(this.name + '跑...');
    }
}

//汽车类
function Car () {
    this.name = "汽车";
}
Car.prototype = Object.assign(Vehicle);

//摩托车类
function Moto () {
    this.name = "摩托车";
}
Moto.prototype = Object.assign(Vehicle);

// 汽车车库
function CarGarage () {
    this.createVehicle = function () {
        return new Car();
    }
    Object.freeze(this);
}

// 摩托车车库
function MotoGarage () {
    this.createVehicle = function () {
        return new Moto();
    }
    Object.freeze(this);
}

// 测试
var carGarage = new CarGarage();
var motoGarage = new MotoGarage();

var car = carGarage.createVehicle();
var moto = motoGarage.createVehicle();
car.run();
moto.run();
```

<br/>

### <b>抽象工厂</b>

<br/>

<b>简要：</b>

对比于工厂方法，抽象工厂可以说是多种产品，每种产品都要用工厂方法实现。

<b>代码示例：</b>

```js
// 生产枪的工厂
// createGun 生产枪
 
// ak47 枪工厂，生产 ak47 枪
function Ak47GunCompany () {
    this.createGun = function () {
        console.log("生产 ak47 枪...");
    }
}
// 巴雷特 枪工厂，生产 巴雷特 枪
function BarrettGunCompany () {
    this.createGun = function () {
        console.log("生产 巴雷特 枪...");
    }
}
 
// 生产子弹的工厂
// createBubble 生产子弹
 
// ak47 子弹工厂，生产 ak47 子弹
function Ak47BubbleCompany () {
    this.createBubble = function () {
        console.log("生产 ak47 子弹...");
    }
}
// 巴雷特 子弹工厂，生产 巴雷特 子弹
function BarrettBubbleCompany () {
    this.createBubble = function () {
        console.log("生产 巴雷特 子弹...");
    }
}
 
// 武器工厂，生产枪和子弹
// createGun 生产枪
// createBubble 生产子弹
 
// ak47 武器工厂，生产 ak47枪 和 ak47 子弹
function Ak47Company () {
    
    var ak47GunCompany = new Ak47GunCompany();
    var ak47BubbleCompany = new Ak47BubbleCompany();
    this.createGun = function () {
        ak47GunCompany.createGun();
    }
    this.createBubble = function () {
        ak47BubbleCompany.createBubble();
    }    
}
 
// 巴雷特 武器工厂，生产 巴雷特枪 和 巴雷特子弹
function BarrettCompany () {
    var barrettGunCompany = new BarrettGunCompany();
    var barrettBubbleCompany = new BarrettBubbleCompany();
    this.createGun = function () {
        barrettGunCompany.createGun();
    }
    this.createBubble = function () {
        barrettBubbleCompany.createBubble();
    }
}
 
var ak47Company = new Ak47Company();
var barrettCompany = new BarrettCompany();
ak47Company.createGun();
ak47Company.createBubble();
barrettCompany.createGun();
barrettCompany.createBubble();
```

<br/>

### <b>建造者模式</b>

<br/>

<b>简要：</b>

当构造一个实例的时候，需要执行多个步骤才能生成实例，并且每个步骤有多种选择从而会生成多种实例的时候使用。

<b>代码示例：</b>

```js
// 适用于 构造一个实例对象需要多个步骤，且每个步骤可能不同会导致不同的实例类
 
/** 果汁制作步骤
 *  StirFruit()  将水果打碎
 *  addWater() 加水
 */
 
// 西瓜汁制作步骤
function WatermelonJuiceStep() {
    
    this.StirFruit = function () {
        console.log("将西瓜打碎...");
    };
    this.addWater = function () {
        console.log("加水...");
    }
}
 
// 橙汁制作步骤
function OrangeJuiceStep() {
 
    this.StirFruit = function () {
        console.log("将橙子打碎...");
    };
    this.addWater = function () {
        console.log("加水...");
    }
}
 
/** 果汁生成器
 *  make() 生成果汁
 *  getJuice() 获取制作的果汁
 */
 
// 西瓜汁生成器
function WatermelonJuiceMaker () {
    
    var maker = new WatermelonJuiceStep();
    this.make = function () {
        maker.StirFruit();
        maker.addWater();
    }
    this.getJuice = function () {
        return maker;
    }
}
 
// 橙汁生成器
function OrangeJuiceMaker () {
 
    var maker = new OrangeJuiceStep();
    this.make = function () {
        maker.StirFruit();
        maker.addWater();
    }
    this.getJuice = function () {
        return maker;
    }
}
 
// 果汁生成器
function JuiceMaker() {
    
    var orangeJuiceMaker = new OrangeJuiceMaker();
    var watermelonJuiceMaker = new WatermelonJuiceMaker();
    this.makeOrangeJuice = function () {
        orangeJuiceMaker.make();
        return orangeJuiceMaker.getJuice();
    }
    this.makeWatermelonJuice = function () {
        watermelonJuiceMaker.make();
        return watermelonJuiceMaker.getJuice();
    }
}
 
// 使用果汁生成器
var juiceMaker = new JuiceMaker();
 
var watermelonJuice = juiceMaker.makeWatermelonJuice();
var orangeJuice = juiceMaker.makeOrangeJuice();
```

<br/>

### <b>2、结构型</b>

<br/>

>图例

![](img/11-2.png)

<br/>

### <b>代理模式</b>

<br/>

<b>简要：</b>

共同继承同一接口或抽象类，代理类包含被代理类（has-a)

<b>代码示例：</b>

```js
// 代理模式
// 共同继承同一接口或抽象类，代理类包含被代理类（has-a)

let Flower = function() {}
let xiaoming = {
  sendFlower: function(target) {
    let flower = new Flower()
    target.receiveFlower(flower)
  }
}
let B = {
  receiveFlower: function(flower) {
    A.listenGoodMood(function() {
      A.receiveFlower(flower)
    })
  }
}
let A = {
  receiveFlower: function(flower) {
    console.log('收到花'+ flower)
  },
  listenGoodMood: function(fn) {
    setTimeout(function() {
      fn()
    }, 1000)
  }
}
xiaoming.sendFlower(B)


 
// 场景：帮别人考试
 
/** 接口（考试人）
 *  test() 参加考试
 */
 
/** 被代理人考试
 * 
 */
function testSelf() {
    this.test = function() {
        console.log("参加考试，可是我不会.");
    }
}
 
/** 代理人考试
 * 
 */
function testOther(self) {
    this.test = function() {
        console.log("参加考试，我会.");
    }
}
 
// 测试
 
var self = new testSelf();
var other = new testOther(self);
other.test();
```

<br/>

### <b>适配器模式</b>

<br/>

<b>简要：</b>

将两个不能一块工作的接口或者类，通过新建一个类继承两者，从而使得可以一起工作

<b>代码示例：</b>

```js
// 适配器模式
// 将两个不能一块工作的接口或者类，通过新建一个类继承两者，从而使得可以一起工作

class Plug {
  getName() {
    return 'iphone充电头';
  }
}

class Target {
  constructor() {
    this.plug = new Plug();
  }
  getName() {
    return this.plug.getName() + ' 适配器Type-c充电头';
  }
}

let target = new Target();
target.getName(); // iphone充电头 适配器转Type-c充电头



 
// 比如小米8的方形耳机插口与圆形耳机接头需要耳机适配器才能工作
 
/** 手机接口
 *  access() 提供的接口类型
 */
 
function Mi8() {
    this.access = function () {
        console.log("小米8提供方形插口.");
    }
}
 
/** 耳机接头
 *  insert() 提供的接头类型
 */
 
function MiHeadset() {
    this.insert = function () {
        console.log("小米耳机提供圆形插头.");
    }
}
 
// 适配器 需要实现 手机接口与耳机接头
function HeadsetAdapter() {
    this.access = function () {
        console.log("耳机适配器提供圆形插口.");
    }
    this.insert = function () {
        console.log("耳机适配器提供方形插头.");
    }
}
 
// 测试
var mi8 = new Mi8();
var miHeadset = new MiHeadset();
var headsetAdapter = new HeadsetAdapter();
mi8.access();
headsetAdapter.insert();
headsetAdapter.access();
miHeadset.insert();
```

<br/>

### <b>桥接模式</b>

<br/>

<b>简要：</b>

主要是两个不同的类有多种种类，通过 has-a 组合方式去进行多种类的结合

<b>示例代码：</b>

```js
// 桥接模式，主要是两个不同的类有多种种类，通过 has-a 组合方式去进行多种类的结合

class Color {
    constructor(name){
        this.name = name
    }
}
class Shape {
    constructor(name,color){
        this.name = name
        this.color = color 
    }
    draw(){
        console.log(`${this.color.name} ${this.name}`)
    }
}

//测试
let red = new Color('red')
let yellow = new Color('yellow')
let circle = new Shape('circle', red)
circle.draw()
let triangle = new Shape('triangle', yellow)
triangle.draw()





/** 场景：
 *  鞋子有跑鞋，篮球鞋，鞋子的品牌有李宁，耐克
 */
 
/** 接口：鞋柜 ShoesBar
 *  saleShoes()  出售鞋子
 */
 
/** 继承鞋柜接口：跑鞋鞋柜 
 * 
 */
function RunShoesBar() {
    this.saleShoes = function () {
        console.log("出售跑鞋.");
    }
}
 
/** 继承鞋柜接口：篮球鞋鞋柜
 *  
 */
function BasketballShoesBar() {
    this.saleShoes = function () {
        console.log("出售篮球鞋.");
    }
}
 
/** 抽象类：品牌鞋柜
 *  shoesBar 继承 ShoesBar 的鞋柜
 *  saleShoes 鞋柜
 */
 
/** 品牌鞋柜继承类：李宁鞋柜
 *  
 */
function LiNingShoesBar(shoesBar) {
    var shoesBar = shoesBar;
    this.saleShoes = function () {
        console.log("李宁鞋柜：");
        shoesBar.saleShoes();
    }
}
 
/** 品牌鞋柜继承类：耐克鞋柜
 * 
 */
function NickShoesBar(shoesBar) {
    var shoesBar = shoesBar;
    this.saleShoes = function () {
        console.log("耐克鞋柜：");
        shoesBar.saleShoes();
    }
}
 
// 测试
// 定义一个跑鞋柜
var runShoesBar = new RunShoesBar();
// 定义一个李宁的跑鞋柜
var liningRunShoesBar = new LiNingShoesBar(runShoesBar);
liningRunShoesBar.saleShoes();
// 定义一个耐克的跑鞋柜
var nickShoesBar = new NickShoesBar(runShoesBar);
nickShoesBar.saleShoes();
```

<br/>

### <b>组合模式</b>

<br/>

<b>简要：</b>

就是不同层级的两个类具有极其相似的结构，可以只构造一个类来表示这两个类

<b>示例代码：</b>

```js
// 组合模式：就是不同层级的两个类具有极其相似的结构，可以只构造一个类来表示这两个类

class TrainOrder {
	create () {
		console.log('创建火车票订单')
	}
}
class HotelOrder {
	create () {
		console.log('创建酒店订单')
	}
}

class TotalOrder {
	constructor () {
		this.orderList = []
	}
	addOrder (order) {
		this.orderList.push(order)
		return this
	}
	create () {
		this.orderList.forEach(item => {
			item.create()
		})
		return this
	}
}
// 可以在购票网站买车票同时也订房间
let train = new TrainOrder()
let hotel = new HotelOrder()
let total = new TotalOrder()
total.addOrder(train).addOrder(hotel).create()





 
// 场景：表示爷爷，爸爸，儿子三代关系
 
// 接口：属于人，都有名字
const Person = {
    getName() {
        return this.name;
    },
    setName(name) {
        this.name = name;
    },
    display () {
 
    }
    
}
 
 
// 爷爷和爸爸都是父亲，都有儿子，所以...
function Father(name) {
    this.setName(name);
    var sons = [];
    this.add = function (person) {
        sons.push(person);
    }
    this.display = function () {
        console.log("作为父亲：" + this.getName());
        sons.forEach((son) => {
            son.display();
        });
    }
}
// 继承一下
Father.prototype = Person;
 
// 作为儿子，只能是儿子
function Son(name) {
    this.setName(name);
    this.display = function () {
        console.log("作为儿子：" + this.getName());
    }
}
// 继承以下
Son.prototype = Person;
 
// 测试
var grandfather = new Father("张爷爷");
var father1 = new Father("张伯伯");
var father2 = new Father("张大爷");
var son1 = new Son("张娃子");
var son2 = new Son("张嘎子");
grandfather.add(father1);
grandfather.add(father2);
father1.add(son1);
father2.add(son2);
grandfather.display();
```

<br/>

### <b>装饰器模式</b>

<br/>

<b>简要：</b>

装饰模式，基本类和装饰类共同继承某个接口或者抽象类， 通过装饰类包含基本类以及在装饰类中添加装饰方法的方式去装饰基本类

<b>代码示例：</b>

```js
class Cellphone {
    create() {
        console.log('生成一个手机')
    }
}
class Decorator {
    constructor(cellphone) {
        this.cellphone = cellphone
    }
    create() {
        this.cellphone.create()
        this.createShell(cellphone)
    }
    createShell() {
        console.log('生成手机壳')
    }
}
// 测试代码
let cellphone = new Cellphone()
cellphone.create()

console.log('------------')
let dec = new Decorator(cellphone)
dec.create()







// 场景：lol 英雄buff, 普通英雄，露露buff，努努buff
 
/** 公共接口：Hero
 *  getBuff() 获取英雄的 buff
 */
function NormalHero() {
    this.getBuff = function () {
        console.log("初始的英雄，无 buff.");
    }
}
 
// 加露露 buff 
function LuLuBuffHero(hero) {
    this.getBuff = function() {
        hero.getBuff();
        console.log("加露露 buff.");
    }
}
 
// 加努努 buff
function NuNuBuffHero(hero) {
    this.getBuff = function () {
        hero.getBuff();
        console.log("加努努 buff.");
    }
}
 
// 测试
var noBuffHero = new NormalHero();
var luluBuffHero = new LuLuBuffHero(noBuffHero);
var nunuBuffHero = new NuNuBuffHero(luluBuffHero);
nunuBuffHero.getBuff();
```

<br/>

### <b>外观模式</b>

<br/>

<b>简要：</b>

通过统一的管理类对内部类管理，同时暴露接口接收来自外部类的消息

<b>代码示例：</b>

```js
//兼容浏览器事件绑定

let addMyEvent = function (el, ev, fn) {
    if (el.addEventListener) {
        el.addEventListener(ev, fn, false)
    } else if (el.attachEvent) {
        el.attachEvent('on' + ev, fn)
    } else {
        el['on' + ev] = fn
    }
}; 


//封装接口

let myEvent = {
    // ...
    stop: e => {
        e.stopPropagation();
        e.preventDefault();
    }
};



/** 外观模式
 *  通过统一的管理类对内部类管理，同时暴露接口接收来自外部类的消息
 */
 
// 场景描述： 需求人员提出需求，开发人员进行开发，测试人员进行测试
// 需求人员不需要通知开发人员去开发，测试人员去测试
// 只需要告诉小组组长这个需求就可以了
 
// 开发人员，负责开发需求
function Developter() {
    this.develop = function(demand_name) {
        console.log("开发人员开发需求：" + demand_name);
    }
}
 
// 测试人员，负责测试需求
function Tester() {
    this.test = function (demand_name) {
        console.log("测试人员测试需求：" + demand_name);
    }
}
 
// 技术部组长，负责安排开发人员开发和测试人员测试
function Leader() {
    var developer = new Developter();
    var tester = new Tester();
    this.processDemand = function (demand_name) {
        developer.develop(demand_name);
        tester.test(demand_name);
    }
}
 
// 需求人员，提出需求
function Demander() {
    var leader = new Leader();
    this.demand = function (demand_name) {
        console.log("提出需求：" + demand_name);
        leader.processDemand(demand_name);
    }
}
 
// 测试
var demand_name = "开发一款MOBA游戏.";
var demander = new Demander();
demander.demand(demand_name);
```

<br/>

### <b>享元模式</b>

<br/>

<b>简要：</b>

对于系统中使用的一些对象可以共享使用，那么每次使用时先判断有没有，有直接使用，没有再去创建，节省内存空间

<b>代码示例：</b>

```js
/** 享元模式
 *  对于系统中使用的一些对象可以共享使用，那么每次使用时先判断有没有
 *  有直接使用，没有再去创建，节省内存空间
 */
 
// 场景1：
// 土豪打英雄联盟，想用哪个皮肤，就用哪个
// 有皮肤直接使用，没有就买买买...
 
/** 英雄皮肤类
 *  name 皮肤名字
 *  show() 皮肤展示
 */
function HeroSkin(name) {
    console.log("玩家购买了" + name + "皮肤");
    this.show = function () {
        console.log("玩家使用了" + name + "皮肤");
    }
}
 
/** 玩家以及拥有的皮肤
 *  useSkin(skinName) 使用皮肤
 */
function Player() {
    var mySkins = {};
    this.useSkin = function (skinName) {
        if (!(skinName in mySkins)) {
            mySkins[skinName] = new HeroSkin(skinName);
        }
        mySkins[skinName].show();
    }
}
 
// 测试
var player = new Player();
player.useSkin("伊泽瑞尔-未来战士");
player.useSkin("锐雯-光明使者");
player.useSkin("锐雯-光明使者");




// 场景2：
// 驾考考生数量与车辆数

let examCarNum = 0         // 驾考车总数
/* 驾考车对象 */
class ExamCar {
    constructor(carType) {
        examCarNum++
        this.carId = examCarNum
        this.carType = carType ? '手动档' : '自动档'
        this.usingState = false    // 是否正在使用
    }

    /* 在本车上考试 */
    examine(candidateId) {
        return new Promise((resolve => {
            this.usingState = true
            console.log(`考生- ${ candidateId } 开始在${ this.carType }驾考车- ${ this.carId } 上考试`)
            setTimeout(() => {
                this.usingState = false
                console.log(`%c考生- ${ candidateId } 在${ this.carType }驾考车- ${ this.carId } 上考试完毕`, 'color:#f40')
                resolve()                       // 0~2秒后考试完毕
            }, Math.random() * 2000)
        }))
    }
}

/* 手动档汽车对象池 */
ManualExamCarPool = {
    _pool: [],                  // 驾考车对象池
    _candidateQueue: [],        // 考生队列

    /* 注册考生 ID 列表 */
    registCandidates(candidateList) {
        candidateList.forEach(candidateId => this.registCandidate(candidateId))
    },

    /* 注册手动档考生 */
    registCandidate(candidateId) {
        const examCar = this.getManualExamCar()    // 找一个未被占用的手动档驾考车
        if (examCar) {
            examCar.examine(candidateId)           // 开始考试，考完了让队列中的下一个考生开始考试
              .then(() => {
                  const nextCandidateId = this._candidateQueue.length && this._candidateQueue.shift()
                  nextCandidateId && this.registCandidate(nextCandidateId)
              })
        } else this._candidateQueue.push(candidateId)
    },

    /* 注册手动档车 */
    initManualExamCar(manualExamCarNum) {
        for (let i = 1; i <= manualExamCarNum; i++) {
            this._pool.push(new ExamCar(true))
        }
    },

    /* 获取状态为未被占用的手动档车 */
    getManualExamCar() {
        return this._pool.find(car => !car.usingState)
    }
}

ManualExamCarPool.initManualExamCar(3)          // 一共有3个驾考车
ManualExamCarPool.registCandidates([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])  // 10个考生来考试
```

<br/>

### <b>3、行为型</b>

<br/>

>图例

![](img/11-3.png)

<br/>

### <b>模板方法</b>

<br/>

<b>简要：</b>

简单而言就是定义子类需要做什么，具体做什么交给子类去做 代码示例（java, 因为 js 没有抽象方法这些，而且我觉得模板方法主要是固定流程，实现交给子类实现）

<b>代码示例：</b>

```js
class Beverage {
    constructor({brewDrink, addCondiment}) {
        this.brewDrink = brewDrink
        this.addCondiment = addCondiment
    }
    /* 烧开水，共用方法 */
    boilWater() { console.log('水已经煮沸=== 共用') }
    /* 倒杯子里，共用方法 */
    pourCup() { console.log('倒进杯子里===共用') }
    /* 模板方法 */
    init() {
        this.boilWater()
        this.brewDrink()
        this.pourCup()
        this.addCondiment()
    }
}
/* 咖啡 */
const coffee = new Beverage({
     /* 冲泡咖啡，覆盖抽象方法 */
     brewDrink: function() { console.log('冲泡咖啡') },
     /* 加调味品，覆盖抽象方法 */
     addCondiment: function() { console.log('加点奶和糖') }
})
coffee.init() 







// 模板方法
// 场景：召唤师选择英雄，皮肤和召唤师技能
// 步骤：选择英雄 -> 选择皮肤 -> 选择召唤师技能1 -> 选择召唤师技能2
// 角色：召唤师（就是玩家）
abstract class Player {
    private String name;
    public Player(String name) {
        this.name = name;
    }
    public abstract void chooseHero();
    public abstract void chooseSkin();
    public abstract void chooseSummonerSkillFirst();
    public abstract void chooseSummonerSkillSecond();
    public void show() {
        // 显示玩家信息
        System.out.println(this.name + "的选择：");
        // 显示选择的英雄
        chooseHero();
        // 显示选择的皮肤
        chooseSkin();
        // 显示选择的召唤师技能一
        chooseSummonerSkillFirst();
        // 显示选择的召唤师技能二
        chooseSummonerSkillSecond();
    }
}
 
// 玩家小明
class XiaoMing extends Player{
    public XiaoMing(){
        super("小明");
    }
    @Override
    public void chooseHero() {
        System.out.println("英雄：奥拉夫");
    }
 
    @Override
    public void chooseSkin() {
        System.out.println("皮肤：铁哥们");
    }
 
    @Override
    public void chooseSummonerSkillFirst() {
        System.out.println("召唤师技能一：疾走");
    }
 
    @Override
    public void chooseSummonerSkillSecond() {
        System.out.println("召唤师技能二：闪现");
    }
}
 
// 玩家小张
class XiaoZhang extends Player {
    public XiaoZhang() {
        super("小张");
    }
    @Override
    public void chooseHero() {
        System.out.println("英雄：锐雯");
    }
 
    @Override
    public void chooseSkin() {
        System.out.println("皮肤：光明使者");
    }
 
    @Override
    public void chooseSummonerSkillFirst() {
        System.out.println("召唤师技能一：传送");
    }
 
    @Override
    public void chooseSummonerSkillSecond() {
        System.out.println("召唤师技能二：闪现");
    }
}
 
public class Test {
    public static void main(String[] args) {
        // 测试
        Player xiaoming = new XiaoMing();
        Player xiaozhang = new XiaoZhang();
        xiaoming.show();
        xiaozhang.show();
    }
}
```

<br/>

### <b>中介者模式</b>

<br/>

<b>简要：</b>

简单来说就是通过中介者进行数据传递，一方提供数据，一方订阅数据

<b>代码示例：</b>

```js
// 中介者模式
// 简单来说就是通过中介者进行数据传递
// 一方提供数据，一方订阅数据
 
// 场景：使用第三方买二手手机
// 购买者去预定手机，当出售者卖该型号的手机时候通知购买者
 
/** 购买者构造函数
 * 
 * @param phoneName 购买人需要的手机
 */
function Buyer(phoneName) {
    this.getPhoneName = function() {
        return phoneName;
    }
    this.callSellerPhone = function(phone) {
        console.log(`联系卖家：${phone}买 ${phoneName}`);
    }
}
 
/** 出售者构造函数
 *  @param phoneName 卖的的手机
 *  @param phone 卖主联系方式
 */
function Seller(phoneName, phone) {
    this.getPhoneName = function() {
        return phoneName;
    }
    this.getPhone = function() {
        return phone;
    }
}
 
/** 中介者构造函数
 *  
 */
function Intermediary() {
    var buyerList = [];
    var sellerList = [];
    this.addBuyer = function(buyer) {
        // 若存在一个合适的卖家，直接通知买主，不添加到列表
        for (let i of sellerList) {
            if (i.getPhoneName() === buyer.getPhoneName()) {
                buyer.callSellerPhone(i.getPhone());
                break;
            }
        }
 
        buyerList.push(buyer);
    }
    this.addSeller = function(seller) {
        // 若存在一个合适的买家，直接通知买主，不添加到列表
        for (let i of buyerList) {
            if (i.getPhoneName() === seller.getPhoneName()) {
                i.callSellerPhone(seller.getPhone());
                break;
            }
        }
 
        sellerList.push(seller);
    }
}
 
 
var intermediary = new Intermediary();
var buyer1 = new Buyer("小米3");
intermediary.addBuyer(buyer1);
var buyer2 = new Buyer("小米8");
intermediary.addBuyer(buyer2);
var seller1 = new Seller("小米8", "15684175538");
intermediary.addSeller(seller1);
```

<br/>

### <b>命令模式</b>

<br/>

<b>简要：</b>

使用命令模式可以在扩展调度中心的时候不修改调度中心的代码

<b>代码示例：</b>

```js
// 命令模式
// 使用命令模式可以在扩展调度中心的时候不修改调度中心的代码
 
// 场景：玩具遥控汽车
 
/** 汽车构造函数
 * 
 */
function ToyCar() {
    this.goOn = function() {
        console.log("小车前进");
    }
    this.stop = function() {
        console.log("小车停止");
    }
    this.speedUp = function() {
        console.log("小车加速");
    }
}
 
/** 命令接口 CarCommand
 *  car 遥控汽车的实例
 *  execute() 执行命令
 */
 
/** 前进的命令 extends CarCommand
 *  @param car 汽车实例 
 */
function GoOnCommand(car) {
    this.execute = function() {
        car.goOn();
    }
}
 
/** 停止的命令 extends CarCommand
 *  @param car 汽车实例
 */
function StopCommand(car) {
    this.execute = function() {
        car.stop();
    }
}
 
/** 加速的命令 extends CarCommand
 *  @param car 汽车实例
 */
function SpeedUpCommand(car) {
    this.execute = function() {
        car.speedUp();
    }
}
 
 
/** 汽车遥控器
 *  setCarCommand() 设置命令
 *  trigger() 触发命令
 */
function CarControlHandle() {
    var carCommand = null;
    this.setCommand = function(newCarCommand) {
        carCommand = newCarCommand;
    }
    this.trigger = function() {
        carCommand.execute();
    }
}
 
// 测试
 
var car = new ToyCar();
var controlHandle = new CarControlHandle();
 
var goOn = new GoOnCommand(car);
controlHandle.setCommand(goOn);
controlHandle.trigger();
 
var stop = new StopCommand(car);
controlHandle.setCommand(stop);
controlHandle.trigger();
 
var speedUp = new SpeedUpCommand(car);
controlHandle.setCommand(speedUp);
controlHandle.trigger();
```

<br/>

### <b>责任链模式</b>

<br/>

<b>简要：</b>

将请求交给一条处理链，处理链上的有多个处理器处理，当处理链上某个处理器处理了该请求，返回处理的结果优点是添加删除处理器时不需要修改内部代码，只需要添加或者删除即可，符合开闭原则

<b>代码示例：</b>

```js
// 责任链模式
// 将请求交给一条处理链，处理链上的有多个处理器处理，
// 当处理链上某个处理器处理了该请求，返回处理的结果
// 优点是添加删除处理器时不需要修改内部代码，只需要添加或者删除即可
// 符合开闭原则
 
// 场景：dnf 玩家刷图打怪，怪物有普通怪，精英怪，boss
 
/** 怪物抽象类
 *  nextMonster 下一个怪物
 *  setNextMonster 设置下一个怪物
 *  battle() 和玩家战斗
 *  battleSuccess() 战斗胜利
 *  battalFail() 战斗失败
 */
 
 
/** 普通怪
 * 
 */
function NomalMonster() {
    var nextMonster = null;
    this.setNextMonster = function(Monster) {
        nextMonster = Monster;
    }
    this.battle = function(player) {
        var res = Math.round(Math.random() * 10) % 2 === 0;
        if (res) {
            this.battleSuccess();
            nextMonster.battle(player);
        } else {
            this.battleFail();
        }
    }
    this.battleSuccess = function() {
        console.log("打败了普通怪.");
    }
    this.battleFail = function() {
        console.log("被普通怪打死, 请使用复活币");
    }
}
 
/** 精英怪
 * 
 */
function CreamMonster() {
    var nextMonster = null;
    this.setNextMonster = function(Monster) {
        nextMonster = Monster;
    }
    this.battle = function(player) {
        var res = Math.round(Math.random() * 10) % 2 === 0;
        if (res) {
            this.battleSuccess();
            nextMonster.battle(player);
        } else {
            this.battleFail();
        }
    }
    this.battleSuccess = function() {
        console.log("打败了精英怪.");
    }
    this.battleFail = function() {
        console.log("被精英怪打死, 请使用复活币");
    }
} 
 
 
/** Boss怪
 * 
 */
function BossMonster() {
    var nextMonster = null;
    this.setNextMonster = function(Monster) {
        nextMonster = Monster;
    }
    this.battle = function(player) {
        var res = Math.round(Math.random() * 10) % 2 === 0;
        if (res) {
            this.battleSuccess();
        } else {
            this.battleFail();
        }
    }
    this.battleSuccess = function() {
        console.log("打败了boss怪，通关成功！");
    }
    this.battleFail = function() {
        console.log("被boss怪打死, 请使用复活币");
    }
}
 
 
/** 玩家类
 * 
 */
function Player() {
 
}
 
// 测试
var player = new Player();
 
var nomalMonster = new NomalMonster();
 
var creamMonster = new CreamMonster();
nomalMonster.setNextMonster(creamMonster);
 
var bossMonster = new BossMonster();
creamMonster.setNextMonster(bossMonster);
 
nomalMonster.battle(player);
```

<br/>

### <b>策略模式</b>

<br/>

<b>简要：</b>

定义一组算法，将每个算法都封装起来，并且使他们之间可以互换

<b>代码示例：</b>

```js
// 策略模式
// 定义一组算法，将每个算法都封装起来，并且使他们之间可以互换
 
// 场景： 五个人租房子，要么找五室一厅，要么三室一厅 + 二室一厅
// 角色：找房人
 
/** 方案接口
 *  sayMethod()  输出方案
 */
 
/** 方案一  五室一厅
 *  sayMethod()  输出方案
 */
function Method1() {
    this.sayMethod = function() {
        console.log("找一个五室一厅.");
    }
}
 
/** 方案二 三室一厅 + 二室一厅
 *  sayMethod()  输出方案
 */
function Method2() {
    this.sayMethod = function() {
        console.log("找一个三室一厅和一个二室一厅");
    }
}
 
 
/** 找房人
 *  method 方案
 *  findHouse() 找房子
 */
function findHousePeople(method) {
    
    this.findHouse = function() {
        method.sayMethod();    
    }
    this.setMethod = function(newMethod) {
        method = newMethod;
    }
}
 
// 测试
var method = new Method1();
var people = new findHousePeople(method);
people.findHouse();
 
method = new Method2();
people.setMethod(method);
people.findHouse();
```

<br/>

### <b>迭代器模式</b>

<br/>

<b>简要：</b>

给定一个遍历规则，不管其数据结构实现

<b>代码示例：</B>

```js
// 迭代器模式
// 给定一个遍历规则，不管其数据结构实现
 
// 场景：排队拿快递
 
/** 学生构造函数
 *  
 */
function Student(name, phone, expressId) {
    this.getName = function() {
        return name;
    }
    this.getPhone = function() {
        return phone;
    }
    this.getExpressId = function() {
        return expressId;
    }
}
 
/** 快递点构造函数
 * 
 */
function ExpressStation() {
    var index = -1;
    var students = [];
    var iterator = null;
    iterator = {
        hasNext() {
            return index < students.length - 1;
        },
        next() {
            index ++;
            return students[index];
        }
    }
    this.getIterator = function() {
        return iterator;
    }
    this.addStudent = function(student) {
        students.push(student);
    }
}
 
// 测试
var s1 = new Student("张三", "15684175538", "5-68-9");
var s2 = new Student("李四", "15806378470", "5-98-6");
 
var expressStation = new ExpressStation();
expressStation.addStudent(s1);
expressStation.addStudent(s2);
 
var iterator = expressStation.getIterator();
while (iterator.hasNext()) {
    var student = iterator.next();
    console.log(`快递员："下一位"`);
    console.log(`学生："${student.getExpressId()}"`);
    console.log(`快递员："姓名，电话"`);
    console.log(`学生: ${student.getName()}, ${student.getPhone()}`);
    console.log();
}
```

<br/>

### <b>观察者模式</b>

<br/>

<b>简要：</b>

定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

<b>代码示例：</b>

```js
// 观察者模式
// 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。
 
// 场景：订阅公众号
 
/** 观察者接口 Observer
 *  update(String barName, String message) 收到消息
 */
 
/** 被观察者接口 Observable
 *  addObserver(Observer ob) 添加观察者
 *  removeObserver(Observe ob) 删除观察者
 *  notifyObservers(String message) 通知所有观察者 
 */
 
/** 微信用户构造函数
 *  
 */
function WxUser() {
    this.update = function(barName, message) {
        console.log(`公众号${barName}发来消息：${message}`);
    }
}
 
/** 微信公众号构造函数
 *  
 */
function WxBar(name) {
    var obs = new Set();
    this.addObserver = function(ob) {
        obs.add(ob);
    }
    this.removeObserver = function(ob) {
        obs.delete(ob);
    }
    this.notifyObservers = function(message) {
        for (let ob of obs) {
            ob.update(name, message);
        }
    }
 
}
 
// 测试
var user1 = new WxUser();
var user2 = new WxUser();
 
var wxBar = new WxBar("党尼玛的公众号");
wxBar.addObserver(user1);
wxBar.addObserver(user2);
wxBar.notifyObservers("这波超级帅！");
```

<br/>

### <b>发布订阅模式</b>

<br/>

<b>简要：</b>

定义对象间一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。其UML图如下所示：

- Subject

    作为发布订阅模式中的发布者，其维护了一个所有订阅它的引用集合，并拥有添加、删除观察者以及通知所有观察者的方法

- Observer

    作为发布订阅模式中的订阅者，为所有具体订阅者定义一个接口，在接到发布者的通知时来更新自己

- 实现步骤：

    首先要指定好谁充当发布者

    然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者

    最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函
数

<br/>

<b>代码示例：</b>

```js
// 首先我们来实现发布者的基类，所有继承该发布者基类的子类都会成为发布者。

// 定义发布者基类
class Subject {
    // 构造函数
    constructor() {
        this.observers = []
    }

    /**
     * 添加订阅者
     */
    add(observer) {
        this.observers.push(obj)
    }

    /**
     * 移除订阅者
     */
    remove(observer) {
        this.observers.forEach((item, index) => {
            if (item === observer) this.observers.splice(index, 1);
        })
    }

    /**
     * 通知消息
     * @param {*} msg 
     */
    notify(msg) {
        this.observers.forEach(item => {
            item.receive(this, msg)
        })
    }
}

//然后我们来定义一个大V类，继承自Subject

/**
 * 定义大V类
 */
class BigV extends Subject {
    constructor(name) {
        super()
        this.name = name
    }

    /**
     * 获取姓名
     */
    getName() {
        return this.name
    }

    /**
     * 添加粉丝
     * @param {} fans 
     */
    addFans(fans) {
        this.add(fans)
    }

    /**
     * 向粉丝推送消息
     * @param {*} msg 
     */
    pushMsg(msg) {
        this.notify(msg)
    }
}

// 定义粉丝类

/**
 * 定义粉丝类
 */
class Fans {
    constructor(name) {
        this.name = name
    }
   /**
    *接受推送消息方法
    */
    receive(bigV, msg) {
        console.log(`我是粉丝${this.name}接收到了大V${bigV.getName}推送的消息：${msg}`)
    }
}

let bigV = new BigV('Eason')
let fans1 = new Fans('Jack')
let fans2 = new Fans('Tom')
bigV.addFans(fans1)
bigV.addFans(fans2)
bigV.pushMsg('祝大家新年快乐！')// 输出： 我是粉丝Jack接收到了大VEason推送的消息：祝大家新年快乐！我是粉丝Tom接收到了大VEason推送的消息：祝大家新年快乐！

//优缺点

//通过上面的代码我们可以看出发布订阅模式的优点是解耦，作为发布者来说不用关心订阅方接收到推送消息之后究竟要做什么，而订阅方则不用关心发布方会何时发布消息。缺点就是创建订阅者本身就会消耗一部分时间和内存，有可能订阅消息到最终都未发生，并且过度使用发布订阅模式会导致程序难以跟踪和理解。
```

<br/>

### <b>状态模式</b>

<br/>

<b>简要:</b>

当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。简单讲就是一个对象有多个状态，且这个对象有几个行为，每个状态的这些行为不同

<b>代码示例：</b>

```js
// 状态模式
// 当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。
// 简单讲就是一个对象有多个状态，且这个对象有几个行为，
// 每个状态的这些行为不同
 
// 场景：文件权限（普通用户只可读，一般管理员可读可写，超级管理员可读可写可删除）
 
/** 状态接口 State
 *  read()  是否可读
 *  write() 是否可写
 *  delete() 是否可删除
 */
 
/** 普通用户状态构造函数
 * 
 */
function NomalUser() {
    this.read = function() {
        console.log("可读");
    }
    this.write = function() {
        console.log("不可写");
    }
    this.delete = function() {
        console.log("不可删除");
    }
}
 
/** 一般管理员状态构造函数
 *  
 */
function Admin() {
    this.read = function() {
        console.log("可读");
    }
    this.write = function() {
        console.log("可写");
    }
    this.delete = function() {
        console.log("不可删除");
    }
}
 
/** 超级管理员构造函数
 * 
 */
function SuperAdmin() {
    this.read = function() {
        console.log("可读");
    }
    this.write = function() {
        console.log("可写");
    }
    this.delete = function() {
        console.log("可删除");
    }
}
 
/** 用户构造函数
 * 
 */
function User(state) {
    this.setState = function(newState) {
        state = newState;
    }
    this.readFile = function() {
        state.read();
    }
    this.writeFile = function() {
        state.write();
    }
    this.deleteFile = function() {
        state.delete();
    }
}
 
// 测试
var user = new User(new NomalUser());
user.readFile();
user.writeFile();
 
user.setState(new SuperAdmin());
user.readFile();
user.writeFile();
user.deleteFile();
```

<br/>

### <b>备忘录模式</b>

<br/>

<b>简要：</b>

三个角色，原发器，备忘录，备忘录守护者。原发器中暴露出两个接口，一个用于包装自己的状态成一个备忘录，另一个用于通过备忘录守护者恢复自身状态，备忘录中只保存原发器的状态，备忘录守护者中维持一个备忘录，可读可写。

<b>代码示例：</b>

```js
// 备忘录模式
// 设置另外的对象作为备忘录对象，保存对象的状态
 
// 场景：英雄联盟购买装备撤回
 
/** 装备备忘录构造函数
 * 
 */
function EquipmentsMemento(equipments) {
    this.setEquipments = function(newEquipments) {
        equipments = newEquipments;
    }
    this.getEquipments = function() {
        return equipments;
    }
}
 
/** 装备栏构造函数 
 *  
 */
function EquipmentBar() {
    var equipments = [];
    this.buyEquipment = function(equipment) {
        console.log(`购买了装备：${equipment}`);
        equipments.push(equipment);
    }
    this.showEquipments = function() {
        console.log("已购买装备: ", equipments.join(" "));
    }
    this.getEquipmentsMemento = function() {
        return new EquipmentsMemento([...equipments]);
    }
    this.recoverEquipments = function(equipmentCaretaker) {
        equipments = equipmentCaretaker.getEquipmentsMemento().getEquipments();
    }
}
 
/** 装备状态管理者构造函数
 * 
 */
function EquipmentCaretaker() {
    var equipmentsMemento = null;
    this.setEquipmentsMemento = function(newEquipmentsMemento) {
        equipmentsMemento = newEquipmentsMemento;
    }
    this.getEquipmentsMemento = function() {
        return equipmentsMemento;
    }
}
 
 
// 测试
 
// 初始化状态看守者
var equipmentCaretaker = new EquipmentCaretaker();
 
// 初始化装备栏
var equipmentBar = new EquipmentBar();
// 购买装备
equipmentBar.buyEquipment("无尽之刃");
equipmentBar.buyEquipment("狂战士胫甲");
 
// 保存当前
equipmentCaretaker.setEquipmentsMemento(equipmentBar.getEquipmentsMemento());
 
// 购买了一件不想要的装备
equipmentBar.buyEquipment("无用大棒");
 
equipmentBar.showEquipments();
 
// 撤回
console.log("玩家买错了，撤回...");
 
equipmentBar.recoverEquipments(equipmentCaretaker);
equipmentBar.showEquipments();
```

<br/>

### <b>解析器模式</b>

<br/>

<b>简要：</b>

给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

<b>代码示例：</b>

```js
// 解释器模式
// 给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
 
// 场景：sql 解释器  
 
/** sql 内容构造函数
 *  
 */
function Context() {
    var tableName = null/** string */;
    var params = null/** object */;
    var wheres = null/** object */;
    var fields = null/** set */;
 
    this.setTableName = function(newTableName) {
        tableName = newTableName;
    }
    this.getTableName = function() {
        return tableName;
    }
 
    this.setParams = function(newParams) {
        params = newParams;
    }
    this.getParams = function() {
        return params;
    }
 
    this.setWheres = function(newWheres) {
        wheres = newWheres;
    }
    this.getWheres = function() {
        return wheres;
    }
 
    this.setFields = function(newFields) {
        fields = newFields;
    }
    this.getFields = function() {
        return fields;
    }
}
 
/** 解释器接口 SQLExpression
 *  string interpret(Context context)
 */
 
/** insert sql 解释器
 * 
 */
function InsertSQLExpression() {
    this.interpret = function(context) {
 
        var params = context.getParams();
 
        // 拼接 key
        var keys = "(";
        var allKey = Object.getOwnPropertyNames(params);
        allKey.forEach((key) => {
            keys += key + ",";
        });
        keys = keys.substring(0, keys.length - 1);
        keys += ")";
 
        // 拼接 value
        var values = "(";
        allKey.forEach((key) => {
            values += (typeof params[key] === 'string' ? `'${params[key]}'` : params[key]) + ",";
        });
        values = values.substring(0, values.length - 1);
        values += ")";
        
        return `insert into ${context.getTableName()} ${keys} values ${values}`;
        
    }
}
 
// 测试
var insertSQLExpression = new InsertSQLExpression();
 
var context = new Context();
context.setTableName("student");
context.setParams({
    name: 'dcw',
    age: 22
});
 
var sql = insertSQLExpression.interpret(context);
console.log(sql)
```

<br/>

### <b>访问者模式</b>

<br/>

<b>简要：</b>

见人说人话，见鬼说鬼话

<b>代码示例：</b>

```js
// 访问者模式
// 见人说人话，见鬼说鬼话
 
// 场景：买衣服时服务员的引导，男生引导到男生区，女生引导到女生区
 
 
/** 服务员抽象类 Waiter
 *  accept(Customer customer)
 */
 
/** 以纯商场服务员 extends Waiter
 *  
 */
function YiChunWaiter() {
    this.accept = function(customer) {
        customer.visit(this);
    }
    // 服务女士
    this.serverWoman = function() {
        console.log("带领女士到女士服装区.");
    }
    // 服务男士
    this.serveMan = function() {
        console.log("带领男士到男士服装区.");
    }
}
 
/** 顾客接口（访问者）
 *  visit(MarketWaiter waiter)
 */
 
/** 女士顾客
 * 
 */
function WomanCustomer() {
    this.visit = function(waiter) {
        waiter.serverWoman();
    }
}
 
/** 男士顾客
 * 
 */
function ManCustomer() {
    this.visit = function(waiter) {
        waiter.serveMan();
    }
}
 
// 测试
var yichunWaiter = new YiChunWaiter();
 
var womanCustomer = new WomanCustomer();
var manCustomer = new ManCustomer();
 
yichunWaiter.accept(womanCustomer);
yichunWaiter.accept(manCustomer);
```

<br/>

## <b>四、代码重构</b>

<br/>

### <b>1、什么是重构</b>

<br/>

>首先，<b style='color:yellow'>重构不是重写。</b>

<br/>

  重构大概的意思是在不影响项目的功能使用前提下，使用一系列的重构方式，改变项目的内部结构。提高项目内部的可读性，可维护性。无论是什么项目，都有一个从简单到复杂的一个迭代过程。在这个过程里面，在不影响项目的使用情况下，需要不断的对代码进行优化，保持或者增加代码的可读性，可维护性。

  这样一来，就可以避免在团队协作开发上需要大量的沟通，交流。才能加入项目的开发中。

<br/>

### <b>2、为什么重构</b>

<br/>

>衣服脏了就洗，破了就补，不合穿就扔。

<br/>

  随着业务需求的不断增加，变更，舍弃，项目的代码也难免会出现瑕疵，这就会影响代码的可读性，可维护性，甚至影响项目的性能。而重构的目的，就是为了解决这些瑕疵，保证代码质量和性能。但是前提是不能影响项目的使用。
  
  <b>至于重构的原因，大概有以下几点：</b>

  - 函数逻辑结构混乱，或因为没注释原因，连原代码写作者都很难理清当中的逻辑。
  - 函数无扩展性可言，遇到新的变化，不能灵活的处理。
  - 因为对象强耦合或者业务逻辑的原因，导致业务逻辑的代码巨大，维护的时候排查困难。
  - 重复代码太多，没有复用性。
  - 随着技术的发展，代码可能也需要使用新特性进行修改。
  - 随着学习的深入，对于以前的代码，是否有着更好的一个解决方案。
  - 因为代码的写法，虽然功能正常使用，但是性能消耗较多，需要换方案进行优化

<br/>

### <b>3、重构要注意什么</b>

<br/>

>在合适的时间，在合适的事情

<br/>

  重构可以说是贯穿整一个项目的开发和维护周期，可以当作重构就是开发的一部分。通俗讲，在开发的任何时候，只要看到代码有别扭，激发了强迫症，就可以考虑重构了。只是，重构之前先参考下面几点：

  - 首先，重构是需要花时间去做的一件事。花的时间可能比之前的开发时间还要多。
  - 其次，重构是为了把代码优化，前提是不能影响项目的使用。
  - 最后，重构的难度大小不一，可能只是稍微改动，可能难度比之前开发还要难。
  
  基于上面的几点，需要大家去评估是否要进行重构。评估的指标，可以参考下面几点
  
  - <span style='color:red'>数量: </span>需要重构的代码是否过多。
  - <span style='color:red'>质量: </span>可读性，可维护性，代码逻辑复杂度，等问题，对代码的质量影响是否到了一个难以忍受的地步。
  - <span style='color:red'>时间: </span>是否有充裕的时间进行重构和测试。
  - <span style='color:red'>效果: </span>如果重构了代码，得到哪些改善，比如代码质量提高了，性能提升了，更好的支持后续功能等。





<br/>

## <b>五、附录：设计模式图示</b>

<br/>

<b>图一</b>

<br/>

![](img/01.jpg)
![](img/02.jpg)
![](img/03.jpg)
![](img/04.jpg)

<br/>

<b>图二</b>

<br/>

![](img/10.png)

<br/>

<b>图三</b>

<br/>

![](img/11.png)

<br/>

<b>图四</b>

<br/>

![](img/12.png)

<br/>

<b>图五</b>

<br/>

![](img/14.jpg)

<br/>

## <b>六、参考文档来源</b>

<br/>

[基于js设计模式的购物车案例](https://github.com/wanghuan19961020/design-pattern-cart)

[14glwu/FEInterviewBox/JS设计模式](https://github.com/14glwu/FEInterviewBox/tree/master/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)

[JavaScript设计模式/考拉海购前端团队](https://juejin.cn/post/6844903503266054157)

[JavaScript 中常见设计模式整理](https://juejin.cn/post/6844903607452581896)

[js实现23种设计模式](https://juejin.cn/post/6844903846523699214#heading-2)

